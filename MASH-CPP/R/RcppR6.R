## Generated by RcppR6: do not edit by hand
## Version: 0.2.4
## Hash: 5fdcdbeb171bdd39381c962fa0564c8a

##' @importFrom Rcpp evalCpp
##' @importFrom R6 R6Class
##' @useDynLib MASHcpp
NULL

##' A class for queueing human events. Header file defined [here](https://github.com/slwu89/RcppQueues/blob/master/inst/include/RcppQueues/HumanEventQ.hpp) and `RcppR6` export handled [here](https://github.com/slwu89/RcppQueues/blob/master/inst/HumanEventQ.yml). Bound to \code{Human$EventQueue} in class \code{\link{Human}}
##' @title Human Event Queue
##' @param initQ reserve memory for \code{initQ} number of events
##' @section Methods:
##'   * firstEvent: return first event in queue as named R list
##'   * firstTime: return 'tEvent' slot in first event in queue
##'   * rmFirstEventFromQ: remove first event in queue and update \code{queueN}
##'   * rmTagFromQ(const std::string &tag): remove all events with certain tag from queue and update \code{queueN}
##'   * get_queueN: return \code{queueN}
##'   * get_EventQ: return entire \code{EventQ} as R list
##'   * addEvent2Q(Rcpp::List event): add a list to the \code{EventQ} in correct time order and update \code{queueN}
##' @section Fields:
##'   * EventQ: \code{std::vector<Rcpp::List>}
##'   * queueN: integer value of size of queue.
##' @md
##' @export
`HumanEventQ` <- function(initQ=10) {
  HumanEventQ__ctor(initQ)
}
.R6_HumanEventQ <-
  R6::R6Class(
    "HumanEventQ",
    inherit=,
    portable=TRUE,
    public=list(
      .ptr=NULL,
      initialize = function(ptr) {
        self$.ptr <- ptr
      },
      firstEvent = function() {
        HumanEventQ__firstEvent(self)
      },
      firstTime = function() {
        HumanEventQ__firstTime(self)
      },
      rmFirstEventFromQ = function() {
        HumanEventQ__rmFirstEventFromQ(self)
      },
      rmTagFromQ = function(tag) {
        HumanEventQ__rmTagFromQ(self, tag)
      },
      get_queueN = function() {
        HumanEventQ__get_queueN(self)
      },
      addEvent2Q = function(event) {
        HumanEventQ__addEvent2Q(self, event)
      },
      get_EventQ = function() {
        HumanEventQ__get_EventQ(self)
      },
      clearQ = function() {
        HumanEventQ__clearQ(self)
      }),
    active=list())

##' A class for recording generic histories comprised of event times (double precision floats) and events (strings).
##' @title Generic History
##' @param N reserve memory for \code{N} number of events
##' @section Methods:
##'   * track_history: record an event from arguments 'tEvent' (double) and 'event' (string)
##'   * get_history: return history as a named list
##' @section Fields:
##'   * eventT: \code{std::vector<double>}
##'   * events: \code{std::vector<std::string>}
##' @md
##' @export
`HistoryGeneric` <- function(N=100) {
  HistoryGeneric__ctor(N)
}
.R6_HistoryGeneric <-
  R6::R6Class(
    "HistoryGeneric",
    inherit=,
    portable=TRUE,
    public=list(
      .ptr=NULL,
      initialize = function(ptr) {
        self$.ptr <- ptr
      },
      track_history = function(tEvent, event) {
        HistoryGeneric__track_history(self, tEvent, event)
      },
      get_history = function() {
        HistoryGeneric__get_history(self)
      }),
    active=list())

##' A class for recording travel histories comprised of event times (double precision floats) and locations (integers).
##' @title Travel History
##' @param N reserve memory for \code{N} number of events
##' @section Methods:
##'   * track_travel: record an event from arguments 'tEvent' (double) and 'event' (string)
##'   * get_travelHistory: return history as a named list
##' @section Fields:
##'   * tTravel: \code{std::vector<double>}
##'   * locationH: \code{std::vector<int>}
##' @md
##' @export
`HistoryTravel` <- function(N=100) {
  HistoryTravel__ctor(N)
}
.R6_HistoryTravel <-
  R6::R6Class(
    "HistoryTravel",
    inherit=,
    portable=TRUE,
    public=list(
      .ptr=NULL,
      initialize = function(ptr) {
        self$.ptr <- ptr
      },
      track_travel = function(tTravel, locationH) {
        HistoryTravel__track_travel(self, tTravel, locationH)
      },
      get_travelHistory = function() {
        HistoryTravel__get_travelHistory(self)
      }),
    active=list())

##' A class for storing parameters and state variables of human-stage PfSI infections.
##' @title PfSI Human Stage Pathogen Class
##' @param PfID_init PfID derived from the tile level PfPedigree
##' @param tInf_init time of current infection (successful mosquito to human transmission event)
##' @param b_init infected mosquito to human transmission efficiency
##' @param c_init infected human to mosquito transmission efficiency
##' @param infected_init infection status
##' @param chemoprophylaxis_init chemoprophylaxis protection status
##' @param N size to preallocate output vectors
##' @section Methods:
##'   * get_PfID:
##'   * push_PfID:
##'   * get_tInf:
##'   * push_tInf:
##'   * get_b:
##'   * set_b:
##'   * get_c:
##'   * set_c:
##'   * get_vectorInf:
##'   * push_vectorInf:
##'   * get_infected:
##'   * set_infected:
##'   * get_chemoprophylaxis:
##'   * set_chemoprophylaxis:
##' @section Fields:
##'   * a field: talk about me
##' @md
##' @export
`humanPfSI` <- function(PfID_init, tInf_init=-1, b_init=0.55, c_init=0.15, infected_init=FALSE, chemoprophylaxis_init=FALSE, N=20) {
  humanPfSI__ctor(PfID_init, tInf_init, b_init, c_init, infected_init, chemoprophylaxis_init, N)
}
.R6_humanPfSI <-
  R6::R6Class(
    "humanPfSI",
    inherit=,
    portable=TRUE,
    public=list(
      .ptr=NULL,
      initialize = function(ptr) {
        self$.ptr <- ptr
      },
      get_PfID = function() {
        humanPfSI__get_PfID(self)
      },
      push_PfID = function(PfID_new) {
        humanPfSI__push_PfID(self, PfID_new)
      },
      back_PfID = function() {
        humanPfSI__back_PfID(self)
      },
      get_tInf = function() {
        humanPfSI__get_tInf(self)
      },
      push_tInf = function(tInf_new) {
        humanPfSI__push_tInf(self, tInf_new)
      },
      get_b = function() {
        humanPfSI__get_b(self)
      },
      set_b = function(b_new) {
        humanPfSI__set_b(self, b_new)
      },
      get_c = function() {
        humanPfSI__get_c(self)
      },
      set_c = function(c_new) {
        humanPfSI__set_c(self, c_new)
      },
      get_vectorInf = function() {
        humanPfSI__get_vectorInf(self)
      },
      push_vectorInf = function(vectorInf_new) {
        humanPfSI__push_vectorInf(self, vectorInf_new)
      },
      get_infected = function() {
        humanPfSI__get_infected(self)
      },
      set_infected = function(infected_new) {
        humanPfSI__set_infected(self, infected_new)
      },
      get_chemoprophylaxis = function() {
        humanPfSI__get_chemoprophylaxis(self)
      },
      set_chemoprophylaxis = function(chemoprophylaxis_new) {
        humanPfSI__set_chemoprophylaxis(self, chemoprophylaxis_new)
      },
      track_history = function(tEvent, event) {
        humanPfSI__track_history(self, tEvent, event)
      },
      get_history = function() {
        humanPfSI__get_history(self)
      }),
    active=list())

##' A class for storing parameters and state variables of mosquito-stage PfSI infections.
##' @title PfSI Mosquito Stage Pathogen Class
##' @param PfID_init PfID derived from the infecting human's gametocytes
##' @param tInf_init time of current infection (successful human to mosquito transmission event)
##' @param infected_init infection status
##' @section Methods:
##'   * get_PfID:
##'   * set_PfID:
##'   * get_tInf:
##'   * set_tInf:
##'   * get_humanInf:
##'   * set_humanInf:
##'   * get_infected:
##'   * set_infected:
##' @section Fields:
##'   * a field: talk about me
##' @md
##' @export
`mosquitoPfSI` <- function(PfID_init, MosquitoID_init, tInf_init=-1, infected_init=FALSE) {
  mosquitoPfSI__ctor(PfID_init, MosquitoID_init, tInf_init, infected_init)
}
.R6_mosquitoPfSI <-
  R6::R6Class(
    "mosquitoPfSI",
    inherit=,
    portable=TRUE,
    public=list(
      .ptr=NULL,
      initialize = function(ptr) {
        self$.ptr <- ptr
      },
      get_PfID = function() {
        mosquitoPfSI__get_PfID(self)
      },
      set_PfID = function(PfID_new) {
        mosquitoPfSI__set_PfID(self, PfID_new)
      },
      get_MosquitoID = function() {
        mosquitoPfSI__get_MosquitoID(self)
      },
      set_MosquitoID = function(MosquitoID_new) {
        mosquitoPfSI__set_MosquitoID(self, MosquitoID_new)
      },
      get_tInf = function() {
        mosquitoPfSI__get_tInf(self)
      },
      set_tInf = function(tInf_new) {
        mosquitoPfSI__set_tInf(self, tInf_new)
      },
      get_humanInf = function() {
        mosquitoPfSI__get_humanInf(self)
      },
      set_humanInf = function(humanInf_new) {
        mosquitoPfSI__set_humanInf(self, humanInf_new)
      },
      get_infected = function() {
        mosquitoPfSI__get_infected(self)
      },
      set_infected = function(infected_new) {
        mosquitoPfSI__set_infected(self, infected_new)
      },
      get_history = function() {
        mosquitoPfSI__get_history(self)
      }),
    active=list())

##' A class for storing parameters and state variables of human-stage PfMOI infections.
##' @title PfMOI Human Stage Pathogen Class
##' @param _PfID PfID for this clonal infection
##' @param _tInf time of successful mosquito to human transmission event for this clonal infection
##' @param _MOI initial multiplicity of infection
##' @param _b mosquito to human transmission efficiency
##' @param _c human to mosquito transmission efficiency
##' @param _chemoprophylaxis chemoprophylaxis protection status
##' @section Methods:
##'   * get_PfID: get vector of current infections by PfID
##'   * get_tInf: get vector of current infections by time of transmisson event
##'   * get_MOI: get current multiplicity of infection
##'   * get_b: get mosquito to human transmission efficiency
##'   * set_b: set mosquito to human transmission efficiency
##'   * get_c: get human to mosquito transmission efficiency
##'   * set_c: set human to mosquito transmission efficiency
##'   * get_chemoprophylaxis: is human currently protected by chemoprophylaxis
##'   * set_chemoprophylaxis: set protection by chemoprophylaxis
##'   * add_Infection: add a new infection
##'   * clear_Infection: completely clear the infection associated with PfID
##'   * clear_Infections: clear all current infections
##'   * get_Infection: get all current infections
##' @section Fields:
##'   * PfID: std::vector<int>
##'   * tInf: std::vector<double>
##'   * MOI: int
##'   * b: double
##'   * c: double
##'   * chemoprophylaxis: bool
##' @md
##' @export
`humanPfMOI` <- function(b_init=0.55, c_init=0.15, chemoprophylaxis_init=FALSE) {
  humanPfMOI__ctor(b_init, c_init, chemoprophylaxis_init)
}
.R6_humanPfMOI <-
  R6::R6Class(
    "humanPfMOI",
    inherit=,
    portable=TRUE,
    public=list(
      .ptr=NULL,
      initialize = function(ptr) {
        self$.ptr <- ptr
      },
      get_PfID = function() {
        humanPfMOI__get_PfID(self)
      },
      get_tInf = function() {
        humanPfMOI__get_tInf(self)
      },
      get_MOI = function() {
        humanPfMOI__get_MOI(self)
      },
      get_b = function() {
        humanPfMOI__get_b(self)
      },
      set_b = function(b_new) {
        humanPfMOI__set_b(self, b_new)
      },
      get_c = function() {
        humanPfMOI__get_c(self)
      },
      set_c = function(c_new) {
        humanPfMOI__set_c(self, c_new)
      },
      get_chemoprophylaxis = function() {
        humanPfMOI__get_chemoprophylaxis(self)
      },
      set_chemoprophylaxis = function(chemoprophylaxis_new) {
        humanPfMOI__set_chemoprophylaxis(self, chemoprophylaxis_new)
      },
      add_Infection = function(PfID_new, tInf_new) {
        humanPfMOI__add_Infection(self, PfID_new, tInf_new)
      },
      clear_Infection = function(PfID_ix) {
        humanPfMOI__clear_Infection(self, PfID_ix)
      },
      clear_Infections = function() {
        humanPfMOI__clear_Infections(self)
      },
      get_Infection = function() {
        humanPfMOI__get_Infection(self)
      }),
    active=list())

##' A class for storing parameters and state variables of mosquito-stage PfMOI infections.
##' @title PfMOI Mosquito Stage Pathogen Class
##' 
##' @section Methods:
##'   * get_PfID:
##'   * push_PfID:
##'   * get_tInf:
##'   * push_tInf:
##'   * get_MOI:
##'   * set_MOI:
##'   * get_damID:
##'   * set_damID:
##'   * get_sireID:
##'   * set_sireID:
##' @section Fields:
##'   * a field: talk about me
##' @md
##' @export
`mosquitoPfMOI` <- function(MosquitoID_init) {
  mosquitoPfMOI__ctor(MosquitoID_init)
}
.R6_mosquitoPfMOI <-
  R6::R6Class(
    "mosquitoPfMOI",
    inherit=,
    portable=TRUE,
    public=list(
      .ptr=NULL,
      initialize = function(ptr) {
        self$.ptr <- ptr
      },
      get_PfID = function() {
        mosquitoPfMOI__get_PfID(self)
      },
      get_MOI = function() {
        mosquitoPfMOI__get_MOI(self)
      },
      add_infection = function(PfID_new, tInfected_new, tInfectious_new) {
        mosquitoPfMOI__add_infection(self, PfID_new, tInfected_new, tInfectious_new)
      },
      get_infections = function(tNow) {
        mosquitoPfMOI__get_infections(self, tNow)
      }),
    active=list())

##' Initialize a risk queue for a feeding site object. This function is a method for \code{\link{FeedingSite}}.
##' @title MICRO Risk Queue
##' @section Methods:
##'   * get_N:
##'   * set_N:
##'   * get_who:
##'   * push_who:
##'   * get_pTm:
##'   * set_pTm:
##'   * get_w:
##'   * push_w:
##'   * set_nOther:
##'   * get_nOther:
##'   * add_OtherHost:
##'   * get_OtherHost:
##' @section Fields:
##'   * a field:
##' @md
##' @export
`RiskQ` <- function() {
  RiskQ__ctor()
}
.R6_RiskQ <-
  R6::R6Class(
    "RiskQ",
    inherit=,
    portable=TRUE,
    public=list(
      .ptr=NULL,
      initialize = function(ptr) {
        self$.ptr <- ptr
      },
      get_N = function() {
        RiskQ__get_N(self)
      },
      set_N = function(N_new) {
        RiskQ__set_N(self, N_new)
      },
      get_who = function() {
        RiskQ__get_who(self)
      },
      push_who = function(who_new) {
        RiskQ__push_who(self, who_new)
      },
      get_pTm = function() {
        RiskQ__get_pTm(self)
      },
      push_pTm = function(pTm_new) {
        RiskQ__push_pTm(self, pTm_new)
      },
      get_w = function() {
        RiskQ__get_w(self)
      },
      push_w = function(w_new) {
        RiskQ__push_w(self, w_new)
      },
      add_HumanHost = function(who_new, pTm_new, w_new) {
        RiskQ__add_HumanHost(self, who_new, pTm_new, w_new)
      },
      get_HumanHost = function() {
        RiskQ__get_HumanHost(self)
      },
      get_HumanHostID = function(ID) {
        RiskQ__get_HumanHostID(self, ID)
      },
      clear_HumanHost = function() {
        RiskQ__clear_HumanHost(self)
      },
      get_nOther = function() {
        RiskQ__get_nOther(self)
      },
      set_nOther = function(nOther_new) {
        RiskQ__set_nOther(self, nOther_new)
      },
      add_OtherHost = function(otherW_new, typeID_new) {
        RiskQ__add_OtherHost(self, otherW_new, typeID_new)
      },
      get_OtherHost = function() {
        RiskQ__get_OtherHost(self)
      }),
    active=list())

##' Initialize a mating queue for a \code{\link[MASHmicro]{MatingSite}} object.
##' @title MICRO Mating Queue
##' @section Methods:
##'   * get_N: write about me!
##'   * add_male2Q: write about me!
##'   * get_MatingQ: write about me!
##'   * clear_MatingQ: write about me!
##' @section Fields:
##'   * a field: write about me!
##' @export
`MatingQ` <- function() {
  MatingQ__ctor()
}
.R6_MatingQ <-
  R6::R6Class(
    "MatingQ",
    inherit=,
    portable=TRUE,
    public=list(
      .ptr=NULL,
      initialize = function(ptr) {
        self$.ptr <- ptr
      },
      get_N = function() {
        MatingQ__get_N(self)
      },
      add_male2Q = function(maleID_new, mateFitness_new, maleGenotype_new) {
        MatingQ__add_male2Q(self, maleID_new, mateFitness_new, maleGenotype_new)
      },
      get_MatingQ = function() {
        MatingQ__get_MatingQ(self)
      },
      clear_MatingQ = function() {
        MatingQ__clear_MatingQ(self)
      }),
    active=list())

##' ImagoQ
##' @title MICRO Imago Queue
##' @section Methods:
##'   * clear_ImagoQ:
##'   * clear_ImagoQTime:
##'   * add_ImagoQ:
##'   * track_ImagoQ:
##'   * get_N:
##'   * set_N:
##'   * get_ImagoQ:
##'   * get_ImagoQTime:
##' @section Fields:
##'   * a field:
##' @md
##' @export
`ImagoQ` <- function() {
  ImagoQ__ctor()
}
.R6_ImagoQ <-
  R6::R6Class(
    "ImagoQ",
    inherit=,
    portable=TRUE,
    public=list(
      .ptr=NULL,
      initialize = function(ptr) {
        self$.ptr <- ptr
      },
      clear_ImagoQ = function() {
        ImagoQ__clear_ImagoQ(self)
      },
      clear_ImagoQTime = function(time) {
        ImagoQ__clear_ImagoQTime(self, time)
      },
      add_ImagoQ = function(N_new, tEmerge_new, genotype_new) {
        ImagoQ__add_ImagoQ(self, N_new, tEmerge_new, genotype_new)
      },
      track_ImagoQ = function(time) {
        ImagoQ__track_ImagoQ(self, time)
      },
      get_N = function() {
        ImagoQ__get_N(self)
      },
      set_N = function(N_new) {
        ImagoQ__set_N(self, N_new)
      },
      get_ImagoQ = function() {
        ImagoQ__get_ImagoQ(self)
      },
      get_ImagoQTime = function(tNow, clear) {
        ImagoQ__get_ImagoQTime(self, tNow, clear)
      }),
    active=list())

##' EggQ
##' @title MICRO Egg Queue
##' @section Methods:
##'   * clear_EggQ:
##'   * clear_EggQTime:
##'   * add_EggQ:
##'   * track_EggQ:
##'   * get_N:
##'   * set_N:
##'   * get_EggQ:
##'   * get_EggQTime:
##' @section Fields:
##'   * a field:
##' @md
##' @export
`EggQ` <- function() {
  EggQ__ctor()
}
.R6_EggQ <-
  R6::R6Class(
    "EggQ",
    inherit=,
    portable=TRUE,
    public=list(
      .ptr=NULL,
      initialize = function(ptr) {
        self$.ptr <- ptr
      },
      clear_EggQ = function() {
        EggQ__clear_EggQ(self)
      },
      clear_EggQTime = function(time) {
        EggQ__clear_EggQTime(self, time)
      },
      add_EggQ = function(N_new, tOviposit_new, genotype_new) {
        EggQ__add_EggQ(self, N_new, tOviposit_new, genotype_new)
      },
      track_EggQ = function(time) {
        EggQ__track_EggQ(self, time)
      },
      get_N = function() {
        EggQ__get_N(self)
      },
      set_N = function(N_new) {
        EggQ__set_N(self, N_new)
      },
      get_EggQ = function() {
        EggQ__get_EggQ(self)
      },
      get_EggQTime = function(tNow, clear) {
        EggQ__get_EggQTime(self, tNow, clear)
      }),
    active=list())

##' Initialize an EL4P pool inside an aquatic site or for a well-mixed macrosimulation tile.
##' This class is nested inside \code{\link{AquaticSite}} or \code{\link{MacroTile}}.
##' Note that genotype corresponding to index 0 is always the wild type.
##' @title Aquatic Ecology EL4P Class
##' @section Methods:
##'   * get_N:
##'   * set_N:
##'   * get_who:
##'   * push_who:
##'   * get_pTm:
##'   * set_pTm:
##'   * get_w:
##'   * push_w:
##'   * set_nOther:
##'   * get_nOther:
##'   * add_OtherHost:
##'   * get_OtherHost:
##' @section Fields:
##'   * a field:
##' @md
##' @export
`EL4P` <- function(numGenotypes, psi_new, alpha_new, p_new) {
  EL4P__ctor(numGenotypes, psi_new, alpha_new, p_new)
}
.R6_EL4P <-
  R6::R6Class(
    "EL4P",
    inherit=,
    portable=TRUE,
    public=list(
      .ptr=NULL,
      initialize = function(ptr) {
        self$.ptr <- ptr
      },
      oneStep = function() {
        EL4P__oneStep(self)
      },
      oneStep_GEL4P = function(M, eqAqua, G, lifespan) {
        EL4P__oneStep_GEL4P(self, M, eqAqua, G, lifespan)
      },
      burnIn_GEL4P = function(M, eqAqua, G, lifespan, tMax) {
        EL4P__burnIn_GEL4P(self, M, eqAqua, G, lifespan, tMax)
      },
      G2K_GEL4P = function(eqAqua, G, lifespan, tMax) {
        EL4P__G2K_GEL4P(self, eqAqua, G, lifespan, tMax)
      },
      checkDX_GEL4P = function(eqAqua, G, lifespan, tMax) {
        EL4P__checkDX_GEL4P(self, eqAqua, G, lifespan, tMax)
      },
      addEggs = function(eggs_N, genotype) {
        EL4P__addEggs(self, eggs_N, genotype)
      },
      get_allGenotypes = function() {
        EL4P__get_allGenotypes(self)
      },
      get_genotypeIx = function(ix) {
        EL4P__get_genotypeIx(self, ix)
      },
      get_psi = function() {
        EL4P__get_psi(self)
      },
      set_psi = function(psi_new) {
        EL4P__set_psi(self, psi_new)
      },
      get_alpha = function() {
        EL4P__get_alpha(self)
      },
      set_alpha = function(alpha_new) {
        EL4P__set_alpha(self, alpha_new)
      },
      get_p = function() {
        EL4P__get_p(self)
      },
      set_p = function(p_new) {
        EL4P__set_p(self, p_new)
      },
      get_numGenotypes = function() {
        EL4P__get_numGenotypes(self)
      },
      get_totalLambda = function() {
        EL4P__get_totalLambda(self)
      },
      get_specificLambda = function(ix) {
        EL4P__get_specificLambda(self, ix)
      },
      reset = function() {
        EL4P__reset(self)
      },
      set_pop = function(initPop) {
        EL4P__set_pop(self, initPop)
      }),
    active=list())

##' ELP
##' @title ELP Class Definition
##' @docType class
##' @format An \code{\link{R6Class}} generator object
##' @keywords R6 class
##' @section **Description**:
##' Generate a single ELP, a simplified model of aquatic ecology which only includes egg and a single larval stage. See \url{https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4357799/} and \url{https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3737150/} for details on model formulation. The daily difference equations are thus formulated as \deqn{L_{t+1}=E_{t}-(\alpha +\gamma +\psi L_{t}^{\sigma})L_{t}} where aquatic stages mature at the constant per-capita rate \eqn{\alpha}. Mortality is given by the per-capita rate \eqn{\alpha +\gamma +\psi L_{t}^{\sigma}}, where \eqn{\gamma} describes all sources of density independent mortality and and the power-law function \eqn{\psi L_{t}^{\sigma}} describes mortality rates as a function of mean density and \eqn{\psi} represents increase in per-capita mortality in response to crowding. For \eqn{\sigma = 1} the relationship gives mean crowding, which is analogous to the classical first-order description of density dependence as described by the logistic growth equation.
##' @section **Constructor**:
##'   * alpha_new = 0.1: daily mautration rate of aquatic stages (1/alpha is expected duration of aquatic life stages)
##'   * psi_new = 0.01: density dependent mortality; increase in per-capita mortality in response to crowding (unit given as 1/L)
##'   * gamma_new = 0.1: daily density independent mortality rate
##'   * sigma_new = 1: scaling relationship of density dependence in response to crowding
##' @section **Methods**:
##'   * oneDay_aquaticDynamics: run daily difference equation for aquatic populations
##'   * get_psi:
##'   * set_psi:
##'   * add_ImagoQ:
##'   * track_ImagoQ:
##'   * get_N:
##'   * set_N:
##'   * get_ImagoQ:
##'   * get_ImagoQTime:
##' @section **Fields**:
##'   * a field:
##' @export
`ELP` <- function(alpha_new=0.1, gamma_new=0.1, psi_new=0.01, tGrain_new=1) {
  ELP__ctor(alpha_new, gamma_new, psi_new, tGrain_new)
}
.R6_ELP <-
  R6::R6Class(
    "ELP",
    inherit=,
    portable=TRUE,
    public=list(
      .ptr=NULL,
      initialize = function(ptr) {
        self$.ptr <- ptr
      },
      oneDay_aquaticDynamics = function(eggIn) {
        ELP__oneDay_aquaticDynamics(self, eggIn)
      },
      oneDay_Emergence = function() {
        ELP__oneDay_Emergence(self)
      },
      ecologicalSimulation = function(g, f, v, L_init, M_init, tMax) {
        ELP__ecologicalSimulation(self, g, f, v, L_init, M_init, tMax)
      },
      ecologicalSimulation2 = function(g_init, f_init, v_init, L_init, M_init, tMax) {
        ELP__ecologicalSimulation2(self, g_init, f_init, v_init, L_init, M_init, tMax)
      },
      get_psi = function() {
        ELP__get_psi(self)
      },
      set_psi = function(psi_new) {
        ELP__set_psi(self, psi_new)
      },
      get_alpha = function() {
        ELP__get_alpha(self)
      },
      set_alpha = function(alpha_new) {
        ELP__set_alpha(self, alpha_new)
      },
      get_gamma = function() {
        ELP__get_gamma(self)
      },
      set_gamma = function(gamma_new) {
        ELP__set_gamma(self, gamma_new)
      },
      get_tGrain = function() {
        ELP__get_tGrain(self)
      },
      get_ELP = function() {
        ELP__get_ELP(self)
      },
      set_ELP = function(L1_new, L2_new, L3_new, L4_new) {
        ELP__set_ELP(self, L1_new, L2_new, L3_new, L4_new)
      },
      get_parameters = function() {
        ELP__get_parameters(self)
      },
      set_parameters = function(alpha_new, gamma_new, psi_new, tGrain_new) {
        ELP__set_parameters(self, alpha_new, gamma_new, psi_new, tGrain_new)
      },
      reset = function() {
        ELP__reset(self)
      }),
    active=list())

##' Class to store female mosquito histories
##' @title Mosquito Female History Class
##' @section Methods:
##'   * historyInit: initialize the mosquito history
##'   * historyTrack: track history at the end of a generic bout (MBITES-XX-Bouts.R)
##'   * historyFeed: track history from a host encounter (MBITES-XX-HostEncounter.R)
##'   * calcBionomics: calculate bionomic parameters upon mosquito death; not intended to be directly called by user.
##'   * exportHistory: export the mosquito history object as a named list which consists of the following components:
##'     * stateH: state trajectory
##'     * timeH: transition times
##'     * ixH: sites visited
##'     * pSetH: point sets visited
##'     * feedAllH: number of blood meals
##'     * feedAllT: times of blood meals
##'     * feedHumanH: number of blood meals on human hosts
##'     * feedHumanT: times of blood meals on human hosts
##'     * feedIxH: ids of all blood hosts
##'     * bmSizeH: size of blood meal
##'     * batchH: size of egg batch
##'     * bionomics_mBatch: mean egg batch size
##'     * bionomics_tBatch: total egg production (sum of all egg batches)
##'     * bionomics_bmInt: all bloodmeal intervals
##'     * bionomics_bmIntH: human bloodmeal intervals
##'     * bionomics_lifespan: lifespan
##' @md
##' @export
`MosquitoFemaleHistory` <- function() {
  MosquitoFemaleHistory__ctor()
}
.R6_MosquitoFemaleHistory <-
  R6::R6Class(
    "MosquitoFemaleHistory",
    inherit=,
    portable=TRUE,
    public=list(
      .ptr=NULL,
      initialize = function(ptr) {
        self$.ptr <- ptr
      },
      historyInit = function(privateEnv) {
        MosquitoFemaleHistory__historyInit(self, privateEnv)
      },
      set_mateID = function(mateID_new) {
        MosquitoFemaleHistory__set_mateID(self, mateID_new)
      },
      historyTrack = function(privateEnv, alive) {
        MosquitoFemaleHistory__historyTrack(self, privateEnv, alive)
      },
      historyFeed = function(privateEnv) {
        MosquitoFemaleHistory__historyFeed(self, privateEnv)
      },
      calcBionomics = function() {
        MosquitoFemaleHistory__calcBionomics(self)
      },
      exportHistory = function() {
        MosquitoFemaleHistory__exportHistory(self)
      }),
    active=list())

##' Class to store male mosquito histories
##' @title Mosquito Male History Class
##' @section Methods:
##'   * a method: write me!
##' @export
`MosquitoMaleHistory` <- function() {
  MosquitoMaleHistory__ctor()
}
.R6_MosquitoMaleHistory <-
  R6::R6Class(
    "MosquitoMaleHistory",
    inherit=,
    portable=TRUE,
    public=list(
      .ptr=NULL,
      initialize = function(ptr) {
        self$.ptr <- ptr
      },
      historyInit = function(privateEnv) {
        MosquitoMaleHistory__historyInit(self, privateEnv)
      },
      historyTrack = function(privateEnv, alive) {
        MosquitoMaleHistory__historyTrack(self, privateEnv, alive)
      },
      exportHistory = function() {
        MosquitoMaleHistory__exportHistory(self)
      }),
    active=list())


