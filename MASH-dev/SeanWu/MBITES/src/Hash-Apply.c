#include <R.h>
#include <Rinternals.h>
#include <R_ext/Rdynload.h>

#include "Hash-Util.h"

/*
 * call: a language object generated by match.call(expand.dots = FALSE)
*/
SEXP hash_apply_c(SEXP call, SEXP rho){

  /* advance to 2nd element (CAR) of call pairlist; 1st element is just the hash_apply function */
  SEXP args = CDR(call);

  /* get environment (2nd element) and advance to 3rd element */
  SEXP envSymbol = install("X");
  args = CDR(args);

  /* get function (3rd element) and advance to 4th element */
  SEXP funSymbol = install("FUN");
  args = CDR(args);

  /* env is the hash table */
  SEXP env = PROTECT(eval(envSymbol,rho));
  int n = HashTableSize(HASHTAB(env), 0);

  /* get the values out of the hash table as vector/list: vals */
  SEXP vals;
  PROTECT(vals = allocVector(VECSXP,n));
  int ix = 0;
  HashTableValues(HASHTAB(env), 0, vals, &ix);

  /* make the bit of the function call that indexes over the values in the hash table */
  SEXP tmp;
  PROTECT(tmp = LCONS(R_Bracket2Symbol, LCONS(envSymbol, R_NilValue)));

  /* make the f(X[[i]],...) bit of the function call (tmp is the indexing) */
  SEXP R_fcall;
  PROTECT(R_fcall = LCONS(funSymbol, LCONS(tmp , LCONS(R_DotsSymbol,R_NilValue))));

  /* map the function(...) over the hash table */
  for(int j=0; j<n; j++){
    SETCADR(R_fcall, VECTOR_ELT(vals, j));
    R_forceAndCall(R_fcall, 1, rho);
  };

  UNPROTECT(4);
  return R_NilValue;
}
